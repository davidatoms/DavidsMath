#!/usr/bin/env python3
"""
Test SU(2) Gauge Group Properties

This script verifies basic properties of the SU(2) gauge group,
which is fundamental to Yang-Mills theory and the Standard Model.

SU(2) is the group of 2×2 unitary matrices with determinant 1.
The Lie algebra su(2) is generated by the Pauli matrices.
"""

import numpy as np
from typing import Tuple

def pauli_matrices() -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Returns the three Pauli matrices (generators of SU(2) Lie algebra).
    
    These satisfy:
    - σᵢ† = σᵢ (Hermitian)
    - σᵢ² = I (each squares to identity)
    - {σᵢ, σⱼ} = 2δᵢⱼI (anticommutator)
    - [σᵢ, σⱼ] = 2iεᵢⱼₖσₖ (commutator)
    """
    sigma1 = np.array([[0, 1], [1, 0]], dtype=complex)
    sigma2 = np.array([[0, -1j], [1j, 0]], dtype=complex)
    sigma3 = np.array([[1, 0], [0, -1]], dtype=complex)
    return sigma1, sigma2, sigma3

def commutator(A: np.ndarray, B: np.ndarray) -> np.ndarray:
    """Compute commutator [A, B] = AB - BA"""
    return A @ B - B @ A

def anticommutator(A: np.ndarray, B: np.ndarray) -> np.ndarray:
    """Compute anticommutator {A, B} = AB + BA"""
    return A @ B + B @ A

def is_hermitian(M: np.ndarray, tol: float = 1e-10) -> bool:
    """Check if matrix is Hermitian (M† = M)"""
    return np.allclose(M, M.conj().T, atol=tol)

def is_unitary(M: np.ndarray, tol: float = 1e-10) -> bool:
    """Check if matrix is unitary (M†M = I)"""
    I = np.eye(M.shape[0])
    return np.allclose(M.conj().T @ M, I, atol=tol)

def test_pauli_hermitian():
    """Test that Pauli matrices are Hermitian"""
    print("Test 1: Pauli matrices are Hermitian")
    sigma1, sigma2, sigma3 = pauli_matrices()
    
    assert is_hermitian(sigma1), "σ₁ is not Hermitian!"
    assert is_hermitian(sigma2), "σ₂ is not Hermitian!"
    assert is_hermitian(sigma3), "σ₃ is not Hermitian!"
    
    print("  ✓ All Pauli matrices are Hermitian")

def test_pauli_square_to_identity():
    """Test that σᵢ² = I"""
    print("\nTest 2: Pauli matrices square to identity")
    sigma1, sigma2, sigma3 = pauli_matrices()
    I = np.eye(2, dtype=complex)
    
    assert np.allclose(sigma1 @ sigma1, I), "σ₁² ≠ I"
    assert np.allclose(sigma2 @ sigma2, I), "σ₂² ≠ I"
    assert np.allclose(sigma3 @ sigma3, I), "σ₃² ≠ I"
    
    print("  ✓ σᵢ² = I for all i")

def test_pauli_commutation_relations():
    """Test that [σᵢ, σⱼ] = 2iεᵢⱼₖσₖ (Lie algebra relations)"""
    print("\nTest 3: SU(2) Lie algebra commutation relations")
    sigma1, sigma2, sigma3 = pauli_matrices()
    sigmas = [sigma1, sigma2, sigma3]
    
    # Levi-Civita symbol (structure constants)
    epsilon = np.zeros((3, 3, 3))
    epsilon[0, 1, 2] = epsilon[1, 2, 0] = epsilon[2, 0, 1] = 1
    epsilon[0, 2, 1] = epsilon[2, 1, 0] = epsilon[1, 0, 2] = -1
    
    for i in range(3):
        for j in range(3):
            comm = commutator(sigmas[i], sigmas[j])
            expected = sum(2j * epsilon[i, j, k] * sigmas[k] for k in range(3))
            assert np.allclose(comm, expected), f"[σ{i+1}, σ{j+1}] commutation failed"
    
    print("  ✓ [σᵢ, σⱼ] = 2iεᵢⱼₖσₖ verified")

def test_pauli_anticommutation():
    """Test that {σᵢ, σⱼ} = 2δᵢⱼI"""
    print("\nTest 4: Pauli anticommutation relations")
    sigma1, sigma2, sigma3 = pauli_matrices()
    sigmas = [sigma1, sigma2, sigma3]
    I = np.eye(2, dtype=complex)
    
    for i in range(3):
        for j in range(3):
            anticomm = anticommutator(sigmas[i], sigmas[j])
            if i == j:
                expected = 2 * I
            else:
                expected = np.zeros((2, 2), dtype=complex)
            assert np.allclose(anticomm, expected), f"{{σ{i+1}, σ{j+1}}} failed"
    
    print("  ✓ {σᵢ, σⱼ} = 2δᵢⱼI verified")

def test_su2_element_is_unitary():
    """Test that exp(iθ·σ/2) is unitary"""
    print("\nTest 5: SU(2) group elements are unitary")
    sigma1, sigma2, sigma3 = pauli_matrices()
    
    # Generate random SU(2) element: exp(i(θ₁σ₁ + θ₂σ₂ + θ₃σ₃)/2)
    theta = np.random.randn(3)
    generator = (theta[0] * sigma1 + theta[1] * sigma2 + theta[2] * sigma3) / 2
    
    # Exponentiate using matrix exponential
    # Use numpy's implementation (available in numpy >= 1.22)
    try:
        from scipy.linalg import expm
        U = expm(1j * generator)
    except ImportError:
        # Fallback to numpy if scipy not available
        from numpy.linalg import matrix_power
        # Taylor series approximation: exp(A) ≈ Σ A^n/n!
        U = np.eye(2, dtype=complex)
        term = np.eye(2, dtype=complex)
        A = 1j * generator
        for n in range(1, 20):  # 20 terms is usually enough
            term = term @ A / n
            U += term
            if np.linalg.norm(term) < 1e-15:
                break
    
    assert is_unitary(U), "Generated SU(2) element is not unitary!"
    assert np.abs(np.linalg.det(U) - 1) < 1e-10, "Determinant is not 1!"
    
    print(f"  ✓ exp(iθ·σ/2) is unitary with det = {np.linalg.det(U):.10f}")

def test_su2_group_closure():
    """Test that SU(2) is closed under multiplication"""
    print("\nTest 6: SU(2) group closure")
    
    def matrix_exp(A):
        """Compute matrix exponential using Taylor series"""
        result = np.eye(A.shape[0], dtype=complex)
        term = np.eye(A.shape[0], dtype=complex)
        for n in range(1, 20):
            term = term @ A / n
            result += term
            if np.linalg.norm(term) < 1e-15:
                break
        return result
    
    sigma1, sigma2, sigma3 = pauli_matrices()
    
    # Generate two random SU(2) elements
    theta1 = np.random.randn(3)
    theta2 = np.random.randn(3)
    
    gen1 = (theta1[0] * sigma1 + theta1[1] * sigma2 + theta1[2] * sigma3) / 2
    gen2 = (theta2[0] * sigma1 + theta2[1] * sigma2 + theta2[2] * sigma3) / 2
    
    U1 = matrix_exp(1j * gen1)
    U2 = matrix_exp(1j * gen2)
    U_product = U1 @ U2
    
    assert is_unitary(U_product), "Product is not unitary!"
    assert np.abs(np.linalg.det(U_product) - 1) < 1e-10, "Product det ≠ 1!"
    
    print("  ✓ U₁ · U₂ ∈ SU(2) (closure verified)")

def display_pauli_matrices():
    """Display the Pauli matrices"""
    print("\n" + "="*60)
    print("PAULI MATRICES (SU(2) Generators)")
    print("="*60)
    
    sigma1, sigma2, sigma3 = pauli_matrices()
    
    print("\nσ₁ (sigma_x):")
    print(sigma1.real)
    
    print("\nσ₂ (sigma_y):")
    print(sigma2)
    
    print("\nσ₃ (sigma_z):")
    print(sigma3.real)
    
    print("\n" + "="*60)

def main():
    """Run all tests"""
    print("="*60)
    print("TESTING SU(2) GAUGE GROUP PROPERTIES")
    print("="*60)
    
    try:
        display_pauli_matrices()
        test_pauli_hermitian()
        test_pauli_square_to_identity()
        test_pauli_commutation_relations()
        test_pauli_anticommutation()
        test_su2_element_is_unitary()
        test_su2_group_closure()
        
        print("\n" + "="*60)
        print("✓ ALL TESTS PASSED!")
        print("="*60)
        print("\nSU(2) satisfies all required gauge group properties:")
        print("  • Generators are Hermitian (Lie algebra)")
        print("  • Commutation relations [σᵢ, σⱼ] = 2iεᵢⱼₖσₖ")
        print("  • Group elements are unitary with det = 1")
        print("  • Closed under multiplication")
        print("\nThis confirms SU(2) is a valid gauge group for Yang-Mills theory!")
        
    except AssertionError as e:
        print(f"\n✗ TEST FAILED: {e}")
        return 1
    except Exception as e:
        print(f"\n✗ ERROR: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())
